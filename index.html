<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>æ­£æ–¹å½¢æå­æ£‹</title>
  <style>
    :root{
      --bg:#101a33;
      --panel:#0f1a33;
      --line:#1f2a44;
      --text:#e8eefc;
      --muted:#a9b6d6;
      --black:#0b0b0b;
      --white:#f2f2f2;
      --accent:#6aa9ff;
      --danger:#ff6a7a;
    }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans TC", Arial;
      background:
        radial-gradient(1200px 800px at 20% 10%, #223a7a 0%, var(--bg) 55%),
        radial-gradient(900px 700px at 85% 15%, rgba(106,169,255,.18) 0%, rgba(0,0,0,0) 55%);
      color:var(--text);
    }

    .wrap{
      max-width:1100px; margin:24px auto; padding:0 16px;
      display:grid; gap:16px; grid-template-columns: 1fr 320px;
    }
    .card{
      background:rgba(15,26,51,.88);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      box-shadow: 0 12px 32px rgba(0,0,0,.35);
    }
    .boardCard{ padding:16px; }
    .side{ padding:16px; display:flex; flex-direction:column; gap:12px; }
    h1{ font-size:18px; margin:0 0 8px 0; letter-spacing:.5px; }
    .sub{ color:var(--muted); font-size:13px; line-height:1.5; }

    .topbar{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; flex-wrap:wrap; }
    .pill{
      display:inline-flex; align-items:center; gap:8px; padding:8px 10px;
      border-radius:999px; background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10); font-size:13px;
    }
    .dot{ width:10px; height:10px; border-radius:50%; }
    .dot.black{ background:var(--black); box-shadow:0 0 0 2px rgba(255,255,255,.15) inset; }
    .dot.white{ background:var(--white); box-shadow:0 0 0 2px rgba(0,0,0,.18) inset; }
    .dot.phase{ background:var(--accent); }
    .scoreRow{ display:flex; gap:8px; flex-wrap:wrap; }

    .board{
      width:min(78vmin, 620px);
      aspect-ratio:1/1;
      margin:0 auto;
      display:grid;
      grid-template-columns: repeat(9, 1fr);
      border-radius:14px;
      overflow:hidden;
      border:3px solid rgba(255,255,255,.25);
      background: rgba(0,0,0,.10);
    }

    .cell{
      position:relative;
      border:2px solid rgba(255,255,255,.18);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer; user-select:none;
      background: rgba(255,255,255,.10);
    }

    .cell.disabled{ cursor:not-allowed; }

    .stone{
      width:70%; height:70%;
      border-radius:50%;
      transform: translateZ(0);
      box-shadow: 0 10px 16px rgba(0,0,0,.35);
      position:relative;
      z-index: 1;
    }
    .stone.black{
      background: radial-gradient(circle at 30% 30%, #2a2a2a 0%, var(--black) 65%);
      outline: 1px solid rgba(255,255,255,.08);
    }
    .stone.white{
      background: radial-gradient(circle at 30% 30%, #ffffff 0%, var(--white) 65%);
      outline: 1px solid rgba(0,0,0,.10);
    }

    .cell.lastmove::after{
      content:"";
      position:absolute;
      width:10px; height:10px;
      border-radius:50%;
      background: rgba(255, 215, 102, .95);
      box-shadow: 0 0 0 2px rgba(0,0,0,.35);
      z-index: 3;
      top:50%; left:50%;
      transform: translate(-50%,-50%);
      pointer-events:none;
    }

    .cell.sqcorner::before{
      content:"";
      position:absolute;
      width:22px; height:22px;
      border-radius:50%;
      border: 2px solid rgba(106,169,255,.95);
      box-shadow: 0 0 0 2px rgba(0,0,0,.22) inset;
      z-index: 2;
      top:50%; left:50%;
      transform: translate(-50%,-50%);
      pointer-events:none;
    }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
      letter-spacing:.2px;
    }
    button:hover{ background: rgba(255,255,255,.10); }
    button:disabled{ opacity:.45; cursor:not-allowed; }
    .primary{ border-color: rgba(106,169,255,.45); background: rgba(106,169,255,.16); }
    .primary:hover{ background: rgba(106,169,255,.22); }
    .danger{ border-color: rgba(255,106,122,.45); background: rgba(255,106,122,.14); }
    .danger:hover{ background: rgba(255,106,122,.20); }

    .list{
      max-height:260px;
      overflow:auto;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
    }
    .item{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.07);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-size:13px;
      cursor:pointer;
    }
    .item:last-child{ border-bottom:none; }
    .item:hover{ background: rgba(255,255,255,.06); }
    .item.sel{ background: rgba(106,169,255,.18); border-bottom-color: rgba(106,169,255,.25); }
    .badge{
      font-size:12px; color:var(--muted);
      padding:3px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      white-space:nowrap;
    }

    .log{
      font-size:13px; line-height:1.5;
      color: var(--muted);
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
      padding:10px;
      min-height:92px;
      white-space:pre-wrap;
    }

    .footerHint{ color:var(--muted); font-size:12px; line-height:1.5; }
    @media (max-width: 920px){
      .wrap{ grid-template-columns: 1fr; }
      .board{ width:min(92vmin, 620px); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card boardCard">
      <div class="topbar">
        <div>
          <h1>æ­£æ–¹å½¢æå­æ£‹ v1.12ï¼ˆ3movesï¼‰</h1>
          <div class="sub">é»‘æ£‹å…ˆè¡Œï¼ˆç©å®¶ï¼é»‘ï¼‰ï¼Œç™½æ£‹ç‚ºæ™ºæ…§ CPUï¼ˆalpha-beta 2â€“3 plyï¼‰ã€‚æ¯å›åˆï¼šä¸‹æ£‹ â†’ï¼ˆè‹¥å¯æå­å‰‡å¿…é ˆæå­ï¼‰â†’ è‡ªå‹•çµæŸå›åˆã€‚</div>
        </div>
        <div class="scoreRow">
          <div class="pill"><span class="dot black" id="turnDot"></span><span id="turnText">é»‘å›åˆ</span></div>
          <div class="pill"><span class="dot phase"></span><span id="phaseText">ä¸‹æ£‹éšæ®µ</span></div>
          <div class="pill"><span>é»‘åˆ†ï¼š</span><b id="scoreB">0</b></div>
          <div class="pill"><span>ç™½åˆ†ï¼š</span><b id="scoreW">0</b></div>
          <div class="pill"><span>ç›®æ¨™ï¼š</span><b>81</b></div>
        </div>
      </div>

      <div class="board" id="board"></div>
    </div>

    <div class="card side">
      <div>
        <div class="pill" style="width:100%; justify-content:space-between;">
          <span>å¯ç”¨æ­£æ–¹å½¢</span>
          <span class="badge" id="sqCount">0</span>
        </div>
        <div class="list" id="sqList"></div>
      </div>

      <div class="btnRow">
        <button class="primary" id="btnCaptureSquare">æå­ï¼ˆç§»é™¤4å­ï¼‰</button>
        <button class="primary" id="btnSkipCapture">è·³éæå­</button>
        <button class="danger" id="btnRestart">é‡æ–°é–‹å§‹</button>
      </div>

      <div class="log" id="log"></div>

      <div class="footerHint">
        æ¨™è¨˜èªªæ˜ï¼š<br>
        â— å¯¦å¿ƒé»ï¼ä¸Šä¸€æ­¥è½å­ä½ç½®<br>
        â—‹ ç©ºå¿ƒåœˆï¼ç›®å‰é¸ä¸­çš„æ­£æ–¹å½¢å››è§’ï¼ˆæå­å¾Œæœƒä¿ç•™ï¼Œç›´åˆ°ä¸‹ä¸€æ¬¡è½å­ï¼‰<br><br>
        æ“ä½œæç¤ºï¼š<br>
        1) ä¸‹æ£‹éšæ®µï¼šé»ç©ºæ ¼ä¸‹ 1 é¡†ã€‚<br>
        2) è‹¥å¯æå­ï¼šå…ˆåœ¨å³å´é¸æ­£æ–¹å½¢ï¼ŒæŒ‰ã€Œæå­ã€å¾—åˆ†ï¼ˆæå®Œè‡ªå‹•çµæŸå›åˆï¼‰ã€‚<br>
        3) è‹¥ç„¡å¯æå­ï¼šè‡ªå‹•çµæŸå›åˆã€‚<br><br>
        <b>æå­è¦å‰‡ï¼š</b>æå­éšæ®µï¼Œè‹¥ã€Œç•¶å‰ç©å®¶çš„ä»»å››é¡†æ£‹ã€èƒ½å½¢æˆæ­£æ–¹å½¢ï¼ˆæ–œçš„ä¹Ÿç®—ï¼‰ï¼Œå³å¯å°‡ã€Œé€™å››é¡†è‡ªå·±çš„æ£‹ã€ææ‰ï¼Œä¸¦ç²å¾—è©²æ­£æ–¹å½¢é¢ç©åˆ†æ•¸ï¼ˆ= é‚Šé•·Â²ï¼‰ã€‚<br>
        <b>å¼·åˆ¶æå­ï¼š</b>è‹¥å­˜åœ¨å¯ç”¨æ­£æ–¹å½¢ï¼Œæœ¬å›åˆå¿…é ˆæå­ï¼ˆå¯é¸è¦æå“ªä¸€å€‹æ­£æ–¹å½¢ï¼‰ã€‚
      </div>
    </div>
  </div>

<script>
(() => {
  const N = 9;
  const TARGET = 81;

  // ===== CPU strength knobs =====
  const CPU_PLY = 3;           // 2 æˆ– 3ï¼š3 æ›´å¼·ä½†æ›´æ…¢
  const CAPTURE_BRANCH = 3;    // æå­åˆ†æ”¯ï¼šåªçœ‹é¢ç©æœ€å¤§çš„å‰ K å€‹

  // ===== helpers =====
  function inBoard(x,y){ return x>=0 && x<N && y>=0 && y<N; }
  function idxOf(x,y){ return y*N + x; }
  function xyOf(i){ return {x: i%N, y: Math.floor(i/N)}; }
  function keyXY(x,y){ return `${x},${y}`; }
  function other(t){ return t === 1 ? 2 : 1; }
  function turnName(t){ return t === 1 ? "é»‘" : "ç™½"; }

  // ===== state =====
  let board = Array.from({length:N}, () => Array(N).fill(0));
  let turn = 1;                 // 1 black, 2 white
  let phase = "place";          // "place" | "capture"
  let placedThisTurn = false;

  let scoreB = 0, scoreW = 0;

  let availableSquares = [];
  let selectedSquareKey = null;
  let captureDoneThisTurn = false;

  let lastMove = null;          // {x,y}
  let pendingClearSquareMarkers = false;

  // ===== DOM =====
  const elBoard = document.getElementById("board");
  const elPhaseText = document.getElementById("phaseText");
  const elTurnText = document.getElementById("turnText");
  const elTurnDot  = document.getElementById("turnDot");
  const elScoreB = document.getElementById("scoreB");
  const elScoreW = document.getElementById("scoreW");
  const elSqList = document.getElementById("sqList");
  const elSqCount = document.getElementById("sqCount");
  const elLog = document.getElementById("log");
  const btnSkipCapture = document.getElementById("btnSkipCapture");
  const btnRestart = document.getElementById("btnRestart");
  const btnCaptureSquare = document.getElementById("btnCaptureSquare");

  // ===== build grid =====
  const cellEls = Array.from({length:N}, () => Array(N).fill(null));
  for (let y=0; y<N; y++){
    for (let x=0; x<N; x++){
      const d = document.createElement("div");
      d.className = "cell";
      d.addEventListener("click", () => onCellClick(x,y));
      elBoard.appendChild(d);
      cellEls[y][x] = d;
    }
  }

  // ===== UI marker helpers =====
  function clearSquareMarkers(){
    for (let y=0; y<N; y++) for (let x=0; x<N; x++) cellEls[y][x].classList.remove("sqcorner");
  }
  function markSquareCorners(cells){
    cells.forEach(c => cellEls[c.y][c.x].classList.add("sqcorner"));
  }

  function logLine(s){
    const cur = elLog.textContent.split("\n");
    if (cur.length && cur[cur.length-1] === s) return;
    elLog.textContent += (elLog.textContent ? "\n" : "") + s;
    elLog.scrollTop = elLog.scrollHeight;
  }

  // ===== Precompute all possible squares (for fast AI) =====
  const ALL_SQUARES = (() => {
    const m = new Map();
    for (let y = 0; y < N; y++) for (let x = 0; x < N; x++) {
      for (let dx = -8; dx <= 8; dx++) for (let dy = -8; dy <= 8; dy++) {
        if (dx === 0 && dy === 0) continue;
        const p = { x, y };
        const q = { x: x + dx, y: y + dy };
        if (!inBoard(q.x, q.y)) continue;
        for (const [rx, ry] of [[-dy, dx], [dy, -dx]]) {
          const r = { x: x + rx, y: y + ry };
          const s = { x: q.x + rx, y: q.y + ry };
          if (!inBoard(r.x, r.y) || !inBoard(s.x, s.y)) continue;

          const cells = [p, q, r, s].map(z => ({ x: z.x, y: z.y }));
          const canon = cells.map(c => keyXY(c.x, c.y)).sort().join("|");
          if (!m.has(canon)) {
            const idxs = cells.map(c => idxOf(c.x, c.y));
            m.set(canon, { cells, idxs, area: dx*dx + dy*dy, key: canon });
          }
        }
      }
    }
    return Array.from(m.values()).sort((a, b) => b.area - a.area);
  })();

  // ===== AI helpers on 1D board =====
  function flattenBoard2D(b2){
    const a = new Uint8Array(N*N);
    let k=0;
    for (let y=0; y<N; y++) for (let x=0; x<N; x++) a[k++] = b2[y][x];
    return a;
  }

  function aiFindFullSquares(b1, color){
    const out = [];
    for (const sq of ALL_SQUARES){
      const a = sq.idxs;
      if (b1[a[0]]===color && b1[a[1]]===color && b1[a[2]]===color && b1[a[3]]===color) out.push(sq);
    }
    return out;
  }

  function aiCountImminent(b1, color){
    let bestArea = 0, sumArea = 0, count = 0;
    for (const sq of ALL_SQUARES){
      let mine=0, empty=0, blocked=false;
      for (const id of sq.idxs){
        const v = b1[id];
        if (v === color) mine++;
        else if (v === 0) empty++;
        else { blocked = true; break; }
      }
      if (blocked) continue;
      if (mine === 3 && empty === 1){
        count++;
        bestArea = Math.max(bestArea, sq.area);
        sumArea += sq.area;
      }
    }
    return {bestArea, sumArea, count};
  }

  function aiCandidateMoves(b1){
    const arr = [];
    for (let i=0; i<N*N; i++){
      if (b1[i] === 0) arr.push(i);
    }
    return arr; // æƒå…¨ç›¤ï¼ˆæœ€å¤š 81ï¼‰
  }

  function aiEval(b1, sB, sW){
    const scoreTerm = (sW - sB) * 10;

    const wIm = aiCountImminent(b1, 2);
    const bIm = aiCountImminent(b1, 1);
    const imminentTerm =
      (wIm.bestArea - bIm.bestArea) * 2 +
      (wIm.sumArea  - bIm.sumArea ) * 2 +
      (wIm.count    - bIm.count   ) * 1;

    let wSt=0, bSt=0;
    for (let i=0;i<N*N;i++){
      if (b1[i]===2) wSt++;
      else if (b1[i]===1) bSt++;
    }
    const stoneTerm = (wSt - bSt) * 1;

    return scoreTerm + imminentTerm + stoneTerm;
  }

  function aiApplyCapture(b1, color, sq){
    const nb = b1.slice();
    for (const id of sq.idxs){
      if (nb[id] === color) nb[id] = 0;
    }
    return { nb, delta: sq.area, sq };
  }

  function aiSimTurn(b1, sB, sW, turnColor, placeIdx, captureSqOrNull){
    const nb = b1.slice();
    nb[placeIdx] = turnColor;

    const squares = aiFindFullSquares(nb, turnColor);
    if (squares.length === 0){
      return { b1: nb, sB, sW, nextTurn: other(turnColor) };
    }

    const sq = captureSqOrNull || squares[0];
    const {nb: nb2, delta} = aiApplyCapture(nb, turnColor, sq);
    if (turnColor === 1) sB += delta;
    else sW += delta;
    return { b1: nb2, sB, sW, nextTurn: other(turnColor) };
  }

  function aiIsTerminal(sB, sW){
    return (sB >= TARGET || sW >= TARGET);
  }

  function alphabeta(b1, sB, sW, turnColor, depth, alpha, beta){
    if (aiIsTerminal(sB, sW) || depth <= 0){
      if (sW >= TARGET) return 999999;
      if (sB >= TARGET) return -999999;
      return aiEval(b1, sB, sW);
    }

    const moves = aiCandidateMoves(b1);
    if (moves.length === 0) return aiEval(b1, sB, sW);

    const isMax = (turnColor === 2);
    let best = isMax ? -Infinity : Infinity;

    for (const m of moves){
      const afterPlace = b1.slice();
      afterPlace[m] = turnColor;
      const squares = aiFindFullSquares(afterPlace, turnColor);

      const captureChoices = (squares.length === 0)
        ? [null]
        : squares.slice(0, CAPTURE_BRANCH);

      for (const cap of captureChoices){
        const st = aiSimTurn(b1, sB, sW, turnColor, m, cap);
        const v = alphabeta(st.b1, st.sB, st.sW, st.nextTurn, depth - 1, alpha, beta);

        if (isMax){
          if (v > best) best = v;
          if (best > alpha) alpha = best;
          if (alpha >= beta) return best;
        } else {
          if (v < best) best = v;
          if (best < beta) beta = best;
          if (alpha >= beta) return best;
        }
      }
    }
    return best;
  }

  function aiPickBestMove(){
    const b1 = flattenBoard2D(board);
    const moves = aiCandidateMoves(b1);
    if (moves.length === 0) return null;

    let bestMove = moves[0];
    let bestVal = -Infinity;

    for (const m of moves){
      const afterPlace = b1.slice();
      afterPlace[m] = 2;
      const squares = aiFindFullSquares(afterPlace, 2);
      const captureChoices = (squares.length === 0)
        ? [null]
        : squares.slice(0, CAPTURE_BRANCH);

      for (const cap of captureChoices){
        const st = aiSimTurn(b1, scoreB, scoreW, 2, m, cap);
        const v = alphabeta(st.b1, st.sB, st.sW, st.nextTurn, CPU_PLY-1, -Infinity, Infinity);
        if (v > bestVal){
          bestVal = v;
          bestMove = m;
        }
      }
    }
    return xyOf(bestMove);
  }

  // ===== game flow =====
  btnSkipCapture.addEventListener("click", () => {
    if (phase !== "capture" || turn !== 1) return;
    if (availableSquares.length > 0) return; // å¼·åˆ¶æå­ï¼šæœ‰æ­£æ–¹å½¢å°±ä¸èƒ½è·³é

    captureDoneThisTurn = true;
    selectedSquareKey = null;
    renderSquares([]);
    logLine(`${turnName(turn)} è·³éæå­ã€‚`);

    if (!isGameOver()){
      setTimeout(() => endTurn(), 200); 
    }
  });

  btnCaptureSquare.addEventListener("click", () => {
    if (phase !== "capture" || turn !== 1) return;
    if (captureDoneThisTurn) return;
    if (availableSquares.length === 0) return;
    if (!selectedSquareKey) return;

    const sq = availableSquares.find(s => s.key === selectedSquareKey);
    if (!sq) return;

    sq.cells.forEach(c => { if (board[c.y][c.x] === 1) board[c.y][c.x] = 0; });

    addScore(1, sq.area);
    captureDoneThisTurn = true;
    pendingClearSquareMarkers = true;

    logLine( +${sq.area}`);
    selectedSquareKey = null;

    renderAll();
    checkWinMaybe();

    if (!isGameOver()){
      setTimeout(() => endTurn(), 250); 
    }
  });

  btnRestart.addEventListener("click", () => resetGame());

  function resetGame(){
    board = Array.from({length:N}, () => Array(N).fill(0));
    turn = 1;
    phase = "place";
    placedThisTurn = false;
    scoreB = 0; scoreW = 0;
    availableSquares = [];
    selectedSquareKey = null;
    captureDoneThisTurn = false;
    lastMove = null;
    pendingClearSquareMarkers = false;
    elLog.textContent = "";
    clearSquareMarkers();
    renderAll();
    logLine("æ–°å±€é–‹å§‹ï¼šé»‘å…ˆã€‚");
  }

  function renderAll(){
    for (let y=0; y<N; y++){
      for (let x=0; x<N; x++){
        const c = cellEls[y][x];
        c.innerHTML = "";
        c.classList.remove("disabled","lastmove");
        const v = board[y][x];
        if (v === 1){
          const s = document.createElement("div");
          s.className = "stone black";
          c.appendChild(s);
        } else if (v === 2){
          const s = document.createElement("div");
          s.className = "stone white";
          c.appendChild(s);
        }
      }
    }

    if (lastMove && inBoard(lastMove.x, lastMove.y)) cellEls[lastMove.y][lastMove.x].classList.add("lastmove");

    elPhaseText.textContent = (phase === "place") ? "ä¸‹æ£‹éšæ®µ" : "æå­éšæ®µ";
    elTurnText.textContent = `${turnName(turn)}å›åˆ`;
    elTurnDot.className = "dot " + (turn === 1 ? "black" : "white");
    elScoreB.textContent = scoreB;
    elScoreW.textContent = scoreW;

    for (let y=0; y<N; y++){
      for (let x=0; x<N; x++){
        const c = cellEls[y][x];
        c.classList.remove("disabled");

        if (phase === "place"){
          if (board[y][x] !== 0 || placedThisTurn || turn !== 1){
            c.classList.add("disabled");
          }
        } else {
          c.classList.add("disabled");
        }
      }
    }

    if (phase === "capture" && turn === 1){
      availableSquares = findSquares2D(1);
      renderSquares(availableSquares);
      elSqCount.textContent = availableSquares.length;
    } else {
      renderSquares([]);
      elSqCount.textContent = 0;
    }

    updateButtons();
  }

  function updateButtons(){
    const isHumanCapture = (phase === "capture" && turn === 1 && !captureDoneThisTurn);
    const mustCapture = isHumanCapture && (availableSquares.length > 0);

    btnCaptureSquare.disabled = !(isHumanCapture && mustCapture && !!selectedSquareKey);
    btnSkipCapture.disabled = !(isHumanCapture && !mustCapture);
  }

  function onCellClick(x,y){
    if (turn !== 1) return;
    if (phase !== "place") return;
    if (placedThisTurn) return;
    if (board[y][x] !== 0) return;

    // ä¸‹ä¸€æ¬¡è½å­æ‰æ¸…æ‰æå­æ¨™è¨˜ï¼ˆç¬¦åˆéœ€æ±‚ï¼‰
    if (pendingClearSquareMarkers) {
      clearSquareMarkers();
      pendingClearSquareMarkers = false;
    } else {
      clearSquareMarkers();
    }

    board[y][x] = 1;
    lastMove = {x,y};
    placedThisTurn = true;

    logLine(`${turnName(1)} (${x+1},${y+1})`);

    phase = "capture";
    captureDoneThisTurn = false;
    selectedSquareKey = null;
    renderAll();

    // âœ… FIX: ç©å®¶è½å­å¾Œè‹¥ç„¡å¯ææ­£æ–¹å½¢ -> è‡ªå‹•çµæŸå›åˆ
    if (availableSquares.length === 0 && !isGameOver()){
      setTimeout(() => endTurn(), 200);
    }
  }

  function endTurn(){
    phase = "place";
    placedThisTurn = false;
    captureDoneThisTurn = false;
    selectedSquareKey = null;

    turn = 2;
    renderAll();
    checkWinMaybe();
    maybeCpuAuto();
  }

  function maybeCpuAuto(){
    if (turn !== 2) return;

    setTimeout(() => {
      cpuPlaceAlphaBeta();

      phase = "capture";
      captureDoneThisTurn = false;
      selectedSquareKey = null;

      const b1 = flattenBoard2D(board);
      const squares = aiFindFullSquares(b1, 2);
      if (squares.length === 0){
        captureDoneThisTurn = true;
        checkWinMaybe();
        setTimeout(endTurnCPU, 250);
        return;
      }

      const sq = squares[0];
      for (const id of sq.idxs){
        const {x,y} = xyOf(id);
        if (board[y][x] === 2) board[y][x] = 0;
      }
      addScore(2, sq.area);

      clearSquareMarkers();
      markSquareCorners(sq.cells);
      pendingClearSquareMarkers = true;

      logLine(`+${sq.area}`);
      captureDoneThisTurn = true;

      renderAll();
      checkWinMaybe();
      setTimeout(endTurnCPU, 300);
    }, 250);
  }

  function endTurnCPU(){
    phase = "place";
    placedThisTurn = false;
    captureDoneThisTurn = false;
    selectedSquareKey = null;
    turn = 1;
    renderAll();
  }

  function cpuPlaceAlphaBeta(){
    if (pendingClearSquareMarkers) {
      clearSquareMarkers();
      pendingClearSquareMarkers = false;
    } else {
      clearSquareMarkers();
    }

    const best = aiPickBestMove();
    if (!best){
      logLine("æ£‹ç›¤å·²æ»¿ã€‚");
      return;
    }

    board[best.y][best.x] = 2;
    lastMove = {x: best.x, y: best.y};

    logLine(`ç™½ (${best.x+1},${best.y+1})`);
    renderAll();
  }

  function addScore(color, delta){
    if (color === 1) scoreB += delta;
    else scoreW += delta;
    elScoreB.textContent = scoreB;
    elScoreW.textContent = scoreW;
  }

  function checkWinMaybe(){
    if (scoreB >= TARGET || scoreW >= TARGET){
      const winner = scoreB >= TARGET ? "é»‘æ–¹ï¼ˆç©å®¶ï¼‰" : "ç™½æ–¹ï¼ˆCPUï¼‰";
      logLine(`\nğŸ ${winner} å…ˆé”åˆ° ${TARGET} åˆ†ï¼Œç²å‹ï¼`);
      for (let y=0; y<N; y++) for (let x=0; x<N; x++) cellEls[y][x].classList.add("disabled");
      btnCaptureSquare.disabled = true;
      btnSkipCapture.disabled = true;
    }
  }
  function isGameOver(){
    return scoreB >= TARGET || scoreW >= TARGET;
  }

  // ===== Find squares for UI list (2D) =====
  function findSquares2D(color){
    const pts = [];
    for (let y=0; y<N; y++) for (let x=0; x<N; x++) if (board[y][x] === color) pts.push({x,y});
    const has = new Set(pts.map(p => keyXY(p.x,p.y)));

    const sqMap = new Map();
    for (let i=0; i<pts.length; i++){
      for (let j=0; j<pts.length; j++){
        if (i === j) continue;
        const p = pts[i], q = pts[j];
        const dx = q.x - p.x, dy = q.y - p.y;
        if (dx === 0 && dy === 0) continue;

        for (const [rx, ry] of [[-dy, dx],[dy, -dx]]){
          const r = {x: p.x + rx, y: p.y + ry};
          const s = {x: q.x + rx, y: q.y + ry};
          if (!inBoard(r.x,r.y) || !inBoard(s.x,s.y)) continue;
          if (!has.has(keyXY(r.x,r.y)) || !has.has(keyXY(s.x,s.y))) continue;

          const cells = [p,q,r,s].map(z => ({x:z.x,y:z.y}));
          const canon = cells.map(z => keyXY(z.x,z.y)).sort().join("|");
          const area = dx*dx + dy*dy;
          if (!sqMap.has(canon)) sqMap.set(canon, { cells, area, key: canon });
        }
      }
    }
    return Array.from(sqMap.values()).sort((a,b) => b.area - a.area);
  }

  function renderSquares(squares){
    elSqList.innerHTML = "";
    if (!squares || squares.length === 0){
      const empty = document.createElement("div");
      empty.className = "item";
      empty.style.cursor = "default";
      empty.style.color = "var(--muted)";
      empty.textContent = (phase === "capture" && turn === 1) ? "ï¼ˆæ²’æœ‰å¯ç”¨æ­£æ–¹å½¢ï¼‰" : "ï¼ˆå›åˆä¸­æ‰æœƒé¡¯ç¤ºï¼‰";
      elSqList.appendChild(empty);
      return;
    }

    squares.forEach((sq, idx) => {
      const it = document.createElement("div");
      it.className = "item" + (sq.key === selectedSquareKey ? " sel" : "");

      const left = document.createElement("div");
      left.textContent = `#${idx+1} é¢ç© ${sq.area}`;

      const right = document.createElement("span");
      right.className = "badge";
      right.textContent = sq.cells.slice().sort((a,b)=> (a.y-b.y)||(a.x-b.x)).map(c=>`(${c.x+1},${c.y+1})`).join(" ");

      it.appendChild(left);
      it.appendChild(right);

      it.addEventListener("click", () => {
        if (phase !== "capture" || turn !== 1) return;
        if (captureDoneThisTurn) return;
        if (availableSquares.length === 0) return;

        selectedSquareKey = sq.key;
        clearSquareMarkers();
        markSquareCorners(sq.cells);

        renderSquares(availableSquares);
        updateButtons();
      });

      elSqList.appendChild(it);
    });
  }

  // init
  resetGame();
})();
</script>
</body>
</html>

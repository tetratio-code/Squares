<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>9Ã—9 æ­£æ–¹å½¢æå­æ£‹</title>
  <style>
    :root{
      --bg:#0b1220; --panel:#0f1a33; --line:#1f2a44; --text:#e8eefc; --muted:#a9b6d6;
      --black:#0b0b0b; --white:#f2f2f2;
      --accent:#6aa9ff; --danger:#ff6a7a; --ok:#44d19a;
    }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans TC", Arial;
      background: radial-gradient(1200px 800px at 20% 10%, #15224a 0%, var(--bg) 55%);
      color:var(--text);
    }
    .wrap{ max-width:1100px; margin:24px auto; padding:0 16px; display:grid; gap:16px;
      grid-template-columns: 1fr 320px;
    }
    .card{ background:rgba(15,26,51,.88); border:1px solid rgba(255,255,255,.08);
      border-radius:16px; box-shadow: 0 12px 32px rgba(0,0,0,.35);
    }
    .boardCard{ padding:16px; }
    .side{ padding:16px; display:flex; flex-direction:column; gap:12px; }
    h1{ font-size:18px; margin:0 0 8px 0; letter-spacing:.5px; }
    .sub{ color:var(--muted); font-size:13px; line-height:1.5; }

    .topbar{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; flex-wrap:wrap; }
    .pill{ display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px;
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); font-size:13px;
    }
    .dot{ width:10px; height:10px; border-radius:50%; }
    .dot.black{ background:var(--black); box-shadow:0 0 0 2px rgba(255,255,255,.15) inset; }
    .dot.white{ background:var(--white); box-shadow:0 0 0 2px rgba(0,0,0,.18) inset; }
    .dot.phase{ background:var(--accent); }
    .scoreRow{ display:flex; gap:8px; flex-wrap:wrap; }

    .board{
      width:min(78vmin, 620px);
      aspect-ratio:1/1;
      margin:0 auto;
      display:grid;
      grid-template-columns: repeat(9, 1fr);
      border-radius:14px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background:
        linear-gradient(0deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    }
    .cell{
      position:relative;
      border:1px solid rgba(255,255,255,.07);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer; user-select:none;
    }
    .cell:hover{ background: rgba(106,169,255,.08); }
    .cell.disabled{ cursor:not-allowed; opacity:.75; }
    .stone{
      width:70%; height:70%;
      border-radius:50%;
      transform: translateZ(0);
      box-shadow: 0 10px 16px rgba(0,0,0,.35);
    }
    .stone.black{
      background: radial-gradient(circle at 30% 30%, #2a2a2a 0%, var(--black) 65%);
      outline: 1px solid rgba(255,255,255,.08);
    }
    .stone.white{
      background: radial-gradient(circle at 30% 30%, #ffffff 0%, var(--white) 65%);
      outline: 1px solid rgba(0,0,0,.10);
    }
    .cell.mark{
      box-shadow: inset 0 0 0 3px rgba(106,169,255,.85);
      background: rgba(106,169,255,.10);
    }
    .cell.captureTarget{
      box-shadow: inset 0 0 0 3px rgba(255,106,122,.9);
      background: rgba(255,106,122,.10);
    }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
      letter-spacing:.2px;
    }
    button:hover{ background: rgba(255,255,255,.10); }
    button:disabled{ opacity:.45; cursor:not-allowed; }
    .primary{ border-color: rgba(106,169,255,.45); background: rgba(106,169,255,.16); }
    .primary:hover{ background: rgba(106,169,255,.22); }
    .danger{ border-color: rgba(255,106,122,.45); background: rgba(255,106,122,.14); }
    .danger:hover{ background: rgba(255,106,122,.20); }

    .list{
      max-height:260px;
      overflow:auto;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
    }
    .item{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.07);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-size:13px;
      cursor:pointer;
    }
    .item:last-child{ border-bottom:none; }
    .item:hover{ background: rgba(255,255,255,.06); }
    .item.sel{ background: rgba(106,169,255,.18); border-bottom-color: rgba(106,169,255,.25); }
    .badge{
      font-size:12px; color:var(--muted);
      padding:3px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      white-space:nowrap;
    }

    .log{
      font-size:13px; line-height:1.5;
      color: var(--muted);
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
      padding:10px;
      min-height:92px;
      white-space:pre-wrap;
    }

    .footerHint{ color:var(--muted); font-size:12px; line-height:1.5; }
    @media (max-width: 920px){
      .wrap{ grid-template-columns: 1fr; }
      .board{ width:min(92vmin, 620px); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card boardCard">
      <div class="topbar">
        <div>
          <h1>9Ã—9 æ­£æ–¹å½¢æå­æ£‹v1.1</h1>
          <div class="sub">é»‘æ£‹å…ˆè¡Œï¼ˆç©å®¶ï¼é»‘ï¼‰ï¼Œç™½æ£‹ç‚ºéš¨æ©Ÿ CPUã€‚æ¯å›åˆï¼šä¸‹æ£‹ â†’ æå­ â†’ çµæŸå›åˆã€‚</div>
        </div>
        <div class="scoreRow">
          <div class="pill" id="turnPill"><span class="dot black" id="turnDot"></span><span id="turnText">é»‘æ–¹å›åˆ</span></div>
          <div class="pill"><span class="dot phase"></span><span id="phaseText">ä¸‹æ£‹éšæ®µ</span></div>
          <div class="pill"><span>é»‘åˆ†ï¼š</span><b id="scoreB">0</b></div>
          <div class="pill"><span>ç™½åˆ†ï¼š</span><b id="scoreW">0</b></div>
          <div class="pill"><span>ç›®æ¨™ï¼š</span><b>81</b></div>
        </div>
      </div>

      <div class="board" id="board"></div>
    </div>

    <div class="card side">
      <div class="sub">
        <b>æå­è¦å‰‡ï¼š</b>æå­éšæ®µï¼Œè‹¥ã€Œç•¶å‰ç©å®¶çš„ä»»å››é¡†æ£‹ã€èƒ½å½¢æˆæ­£æ–¹å½¢ï¼ˆæ–œçš„ä¹Ÿç®—ï¼‰ï¼Œå³å¯å°‡ã€Œé€™å››é¡†è‡ªå·±çš„æ£‹ã€ææ‰ï¼Œä¸¦ç²å¾—è©²æ­£æ–¹å½¢é¢ç©åˆ†æ•¸ï¼ˆ= é‚Šé•·Â²ï¼‰ã€‚
      </div>

      <div>
        <div class="pill" style="width:100%; justify-content:space-between;">
          <span>å¯ç”¨æ­£æ–¹å½¢</span>
          <span class="badge" id="sqCount">0</span>
        </div>
        <div class="list" id="sqList"></div>
      </div>

      <div class="btnRow">
        <button class="primary" id="btnCaptureSquare">æå­ï¼ˆç§»é™¤4å­ï¼‰</button>
        <button class="primary" id="btnSkipCapture">è·³éæå­</button>
        <button class="primary" id="btnEndTurn">çµæŸå›åˆ â†’</button>
        <button class="danger" id="btnRestart">é‡æ–°é–‹å§‹</button>
      </div>

      <div class="log" id="log"></div>

      <div class="footerHint">
        æ“ä½œæç¤ºï¼š<br>
        1) ä¸‹æ£‹éšæ®µï¼šé»ç©ºæ ¼ä¸‹ 1 é¡†ã€‚<br>
        2) é€²å…¥æå­éšæ®µå¾Œï¼šå…ˆåœ¨å³å´é¸ä¸€å€‹æ­£æ–¹å½¢ï¼ˆæœƒé«˜äº® 4 é¡†æ£‹ï¼‰ï¼ŒæŒ‰ã€Œæå­ï¼ˆç§»é™¤4å­ï¼‰ã€å¾—åˆ†ï¼›æˆ–æŒ‰ã€Œè·³éæå­ã€ã€‚<br>
        3) æŒ‰ã€ŒçµæŸå›åˆã€æ›å°æ–¹ã€‚å…ˆé” 81 åˆ†è€…å‹ã€‚
      </div>
    </div>
  </div>

<script>
(() => {
  const N = 9;
  const TARGET = 81;

  // board[y][x] = 0 empty, 1 black, 2 white
  let board = Array.from({length:N}, () => Array(N).fill(0));
  let turn = 1; // 1 black, 2 white
  let phase = "place"; // "place" | "capture"
  let placedThisTurn = false;

  let scoreB = 0, scoreW = 0;

  // capture UI state
  let availableSquares = []; // {cells:[{x,y}..4], area, key}
  let selectedSquareKey = null;
  let captureDoneThisTurn = false;

  // DOM
  const elBoard = document.getElementById("board");
  const elPhaseText = document.getElementById("phaseText");
  const elTurnText = document.getElementById("turnText");
  const elTurnDot  = document.getElementById("turnDot");
  const elScoreB = document.getElementById("scoreB");
  const elScoreW = document.getElementById("scoreW");
  const elSqList = document.getElementById("sqList");
  const elSqCount = document.getElementById("sqCount");
  const elLog = document.getElementById("log");
  const btnSkipCapture = document.getElementById("btnSkipCapture");
  const btnEndTurn = document.getElementById("btnEndTurn");
  const btnRestart = document.getElementById("btnRestart");
  const btnCaptureSquare = document.getElementById("btnCaptureSquare");


  // build grid
  const cellEls = Array.from({length:N}, () => Array(N).fill(null));
  for (let y=0; y<N; y++){
    for (let x=0; x<N; x++){
      const d = document.createElement("div");
      d.className = "cell";
      d.dataset.x = x;
      d.dataset.y = y;
      d.addEventListener("click", () => onCellClick(x,y));
      elBoard.appendChild(d);
      cellEls[y][x] = d;
    }
  }

  btnSkipCapture.addEventListener("click", () => {
    if (phase !== "capture") return;
    captureDoneThisTurn = true;
    selectedSquareKey = null;
    clearMarks();
    renderSquares([]);
    logLine(`${turnName(turn)} è·³éæå­ã€‚`);
    updateButtons();
  });
  btnCaptureSquare.addEventListener("click", () => {
    if (phase !== "capture") return;
    if (turn === 2) return;              // CPU è‡ªå·±æœƒåš
    if (captureDoneThisTurn) return;
    if (!selectedSquareKey) {
      logLine("è«‹å…ˆåœ¨å³å´é¸ä¸€å€‹æ­£æ–¹å½¢ã€‚");
      return;
    }
    const sq = availableSquares.find(s => s.key === selectedSquareKey);
    if (!sq) return;
  
    // ç§»é™¤è‡ªå·±å½¢æˆæ­£æ–¹å½¢çš„å››é¡†æ£‹
    sq.cells.forEach(c => {
      if (board[c.y][c.x] === turn) board[c.y][c.x] = 0;
    });
  
    // å¾—åˆ†
    addScore(turn, sq.area);
  
    captureDoneThisTurn = true;
    logLine(`${turnName(turn)} æå­ï¼šç§»é™¤è‡ªå·± 4 å­ï¼ˆé¢ç© ${sq.area}ï¼‰ï¼Œå¾—åˆ† +${sq.area}ã€‚`);
  
    selectedSquareKey = null;
    clearMarks();
    renderAll();
    checkWinMaybe();
  });

  btnEndTurn.addEventListener("click", () => {
    if (!canEndTurn()) return;
    endTurn();
  });

  btnRestart.addEventListener("click", () => {
    resetGame();
  });

  function resetGame(){
    board = Array.from({length:N}, () => Array(N).fill(0));
    turn = 1;
    phase = "place";
    placedThisTurn = false;
    scoreB = 0; scoreW = 0;
    availableSquares = [];
    selectedSquareKey = null;
    captureDoneThisTurn = false;
    elLog.textContent = "";
    renderAll();
    logLine("æ–°å±€é–‹å§‹ï¼šé»‘æ£‹å…ˆè¡Œã€‚");
    maybeCpuAuto(); // (é»‘æ–¹å…ˆï¼Œä¸æœƒå‹•)
  }

  function renderAll(){
    // stones
    for (let y=0; y<N; y++){
      for (let x=0; x<N; x++){
        const c = cellEls[y][x];
        c.innerHTML = "";
        c.classList.remove("disabled","mark","captureTarget");
        const v = board[y][x];
        if (v === 1){
          const s = document.createElement("div");
          s.className = "stone black";
          c.appendChild(s);
        } else if (v === 2){
          const s = document.createElement("div");
          s.className = "stone white";
          c.appendChild(s);
        }
      }
    }

    // top pills
    elPhaseText.textContent = (phase === "place") ? "ä¸‹æ£‹éšæ®µ" : "æå­éšæ®µ";
    elTurnText.textContent = `${turnName(turn)}å›åˆ`;
    elTurnDot.className = "dot " + (turn === 1 ? "black" : "white");
    elScoreB.textContent = scoreB;
    elScoreW.textContent = scoreW;

    // disable logic
    for (let y=0; y<N; y++){
      for (let x=0; x<N; x++){
        const c = cellEls[y][x];
        if (phase === "place"){
          if (board[y][x] !== 0 || placedThisTurn || turn === 2) c.classList.add("disabled");
        } else { // capture
          // during capture, allow clicking opponent stones only when a square selected
          if (turn === 2) {
            // CPU will auto-handle; disable all clicks
            c.classList.add("disabled");
          } else {
            // player capture phase
            c.classList.add("disabled");
          }
        }
      }
    }

    // squares list refresh when entering capture on human turn
    if (phase === "capture" && turn === 1){
      availableSquares = findSquares(turn);
      renderSquares(availableSquares);
      elSqCount.textContent = availableSquares.length;
    } else {
      renderSquares([]);
      elSqCount.textContent = 0;
    }

    updateButtons();
  }

  function updateButtons(){
    const isHumanCapture = (phase === "capture" && turn === 1 && !captureDoneThisTurn);
    btnCaptureSquare.disabled = !(isHumanCapture && !!selectedSquareKey && availableSquares.length > 0);
    btnSkipCapture.disabled = !isHumanCapture;
    btnEndTurn.disabled = !canEndTurn();
  }


  function canEndTurn(){
    if (turn === 2) return false; // CPU will end itself
    if (phase === "place") return false;
    // capture phase: you can end after you either captured or skipped or have no squares
    if (availableSquares.length === 0) return true; // nothing to do
    return captureDoneThisTurn;
  }

  function onCellClick(x,y){
    if (turn === 2) return; // CPU
    if (phase === "place"){
      if (placedThisTurn) return;
      if (board[y][x] !== 0) return;
      board[y][x] = turn;
      placedThisTurn = true;
      logLine(`${turnName(turn)} ä¸‹åœ¨ (${x+1},${y+1})ã€‚`);
      // auto enter capture phase
      phase = "capture";
      captureDoneThisTurn = false;
      selectedSquareKey = null;
      clearMarks();
      renderAll();

      // if no squares, allow end turn immediately
      if (availableSquares.length === 0){
        logLine(`${turnName(turn)} æ²’æœ‰å¯ç”¨æ­£æ–¹å½¢ï¼Œæœ¬å›åˆç„¡æ³•æå­ã€‚å¯ç›´æ¥çµæŸå›åˆã€‚`);
      } else {
        logLine(`è«‹å…ˆåœ¨å³å´é¸ä¸€å€‹æ­£æ–¹å½¢ï¼Œå†é»ä¸€é¡†ç™½å­æèµ°ä¸¦å¾—åˆ†ï¼›æˆ–è·³éæå­ã€‚`);
      }
      return;
    }

    // capture phase (human): click opponent stone to remove if square selected
    if (phase === "capture"){
      return;
    }
  }

  function endTurn(){
    // swap turn and reset phase
    phase = "place";
    placedThisTurn = false;
    captureDoneThisTurn = false;
    selectedSquareKey = null;
    clearMarks();
    turn = other(turn);
    renderAll();

    checkWinMaybe();
    maybeCpuAuto();
  }

  function maybeCpuAuto(){
    if (turn !== 2) return;
    // CPU "one full round": place -> capture (optional) -> end
    setTimeout(() => {
      cpuPlace();
      // enter capture automatically
      phase = "capture";
      captureDoneThisTurn = false;
      selectedSquareKey = null;

      // compute squares and maybe capture
      availableSquares = findSquares(2);
      if (availableSquares.length === 0){
        logLine(`ç™½æ–¹ï¼ˆCPUï¼‰æ²’æœ‰å¯ç”¨æ­£æ–¹å½¢ï¼Œç„¡æ³•æå­ã€‚`);
        captureDoneThisTurn = true;
        checkWinMaybe();
        setTimeout(() => endTurnCPU(), 350);
        return;
      }

      // pick a random square, capture a random opponent stone
      const sq = availableSquares[Math.floor(Math.random()*availableSquares.length)];
      sq.cells.forEach(c => {
        if (board[c.y][c.x] === 2) board[c.y][c.x] = 0;
      });
      addScore(2, sq.area);
      
      logLine(`ç™½æ–¹ï¼ˆCPUï¼‰æå­ï¼šç§»é™¤è‡ªå·± 4 å­ï¼ˆé¢ç© ${sq.area}ï¼‰ï¼Œå¾—åˆ† +${sq.area}ã€‚`);
      captureDoneThisTurn = true;
      renderAll();
      checkWinMaybe();
      setTimeout(() => endTurnCPU(), 450);
    }, 350);
  }

  function endTurnCPU(){
    // CPU ends its turn
    phase = "place";
    placedThisTurn = false;
    captureDoneThisTurn = false;
    selectedSquareKey = null;
    clearMarks();
    turn = 1;
    renderAll();
  }

  function cpuPlace(){
    // pick random empty
    const empties = [];
    for (let y=0; y<N; y++) for (let x=0; x<N; x++) if (board[y][x] === 0) empties.push({x,y});
    if (empties.length === 0){
      logLine("æ£‹ç›¤å·²æ»¿ã€‚");
      return;
    }
    const p = empties[Math.floor(Math.random()*empties.length)];
    board[p.y][p.x] = 2;
    logLine(`ç™½æ–¹ï¼ˆCPUï¼‰ä¸‹åœ¨ (${p.x+1},${p.y+1})ã€‚`);
    renderAll();
  }

  function addScore(color, delta){
    if (color === 1) scoreB += delta;
    else scoreW += delta;
    elScoreB.textContent = scoreB;
    elScoreW.textContent = scoreW;
  }

  function checkWinMaybe(){
    if (scoreB >= TARGET || scoreW >= TARGET){
      const winner = scoreB >= TARGET ? "é»‘æ–¹ï¼ˆç©å®¶ï¼‰" : "ç™½æ–¹ï¼ˆCPUï¼‰";
      logLine(`\nğŸ ${winner} å…ˆé”åˆ° ${TARGET} åˆ†ï¼Œç²å‹ï¼`);
      // lock UI by disabling clicks
      for (let y=0; y<N; y++) for (let x=0; x<N; x++) cellEls[y][x].classList.add("disabled");
      btnSkipCapture.disabled = true;
      btnEndTurn.disabled = true;
    }
  }

  function turnName(t){ return t === 1 ? "é»‘æ–¹" : "ç™½æ–¹"; }
  function other(t){ return t === 1 ? 2 : 1; }

  function logLine(s){
    elLog.textContent += (elLog.textContent ? "\n" : "") + s;
    elLog.scrollTop = elLog.scrollHeight;
  }

  // -------- Squares detection (any orientation) --------
  // If current player's 4 stones form a square:
  // pick side vector v = q-p, r = p + rot90(v), s = q + rot90(v)
  // area = |v|^2 = dx^2 + dy^2
  function findSquares(color){
    const pts = allStones(color); // array of {x,y}
    const has = new Set(pts.map(p => keyXY(p.x,p.y)));

    const sqMap = new Map(); // key -> square
    for (let i=0; i<pts.length; i++){
      for (let j=0; j<pts.length; j++){
        if (i === j) continue;
        const p = pts[i], q = pts[j];
        const dx = q.x - p.x, dy = q.y - p.y;
        if (dx === 0 && dy === 0) continue;

        // two orientations
        for (const rot of [[-dy, dx],[dy, -dx]]){
          const rx = rot[0], ry = rot[1];
          const r = {x: p.x + rx, y: p.y + ry};
          const s = {x: q.x + rx, y: q.y + ry};

          if (!inBoard(r.x,r.y) || !inBoard(s.x,s.y)) continue;
          if (!has.has(keyXY(r.x,r.y)) || !has.has(keyXY(s.x,s.y))) continue;

          const cells = [p,q,r,s].map(z => ({x:z.x,y:z.y}));
          const canon = cells
            .map(z => keyXY(z.x,z.y))
            .sort()
            .join("|");

          const area = dx*dx + dy*dy; // side length squared
          if (!sqMap.has(canon)){
            sqMap.set(canon, { cells, area, key: canon });
          } else {
            // same square found via different edge direction; keep one (area same)
          }
        }
      }
    }

    // return sorted (bigger first) to make it easier to pick high score
    return Array.from(sqMap.values()).sort((a,b) => b.area - a.area);
  }

  function allStones(color){
    const pts = [];
    for (let y=0; y<N; y++){
      for (let x=0; x<N; x++){
        if (board[y][x] === color) pts.push({x,y});
      }
    }
    return pts;
  }

  function inBoard(x,y){ return x>=0 && x<N && y>=0 && y<N; }
  function keyXY(x,y){ return `${x},${y}`; }

  // -------- Square list + highlights --------
  function renderSquares(squares){
    elSqList.innerHTML = "";
    if (!squares || squares.length === 0){
      const empty = document.createElement("div");
      empty.className = "item";
      empty.style.cursor = "default";
      empty.style.color = "var(--muted)";
      empty.textContent = (phase === "capture" && turn === 1) ? "ï¼ˆæ²’æœ‰å¯ç”¨æ­£æ–¹å½¢ï¼‰" : "ï¼ˆå›åˆä¸­æ‰æœƒé¡¯ç¤ºï¼‰";
      elSqList.appendChild(empty);
      return;
    }

    squares.forEach((sq, idx) => {
      const it = document.createElement("div");
      it.className = "item" + (sq.key === selectedSquareKey ? " sel" : "");
      const left = document.createElement("div");
      left.textContent = `#${idx+1} é¢ç© ${sq.area}`;
      const right = document.createElement("span");
      right.className = "badge";
      right.textContent = formatCells(sq.cells);
      it.appendChild(left);
      it.appendChild(right);

      it.addEventListener("click", () => {
        if (phase !== "capture" || turn !== 1) return;
        if (captureDoneThisTurn) return;

        selectedSquareKey = sq.key;
        clearMarks();
        markSquare(sq.cells);
        renderSquares(availableSquares);

        logLine(`å·²é¸æ­£æ–¹å½¢ï¼ˆé¢ç© ${sq.area}ï¼‰ï¼šæŒ‰ã€Œæå­ï¼ˆç§»é™¤4å­ï¼‰ã€å³å¯å¾—åˆ†ã€‚`);
        renderAll(); // refresh capture target highlights
      });

      elSqList.appendChild(it);
    });
  }

  function formatCells(cells){
    // show as (x,y) list 1-based
    const arr = cells.slice()
      .sort((a,b) => (a.y-b.y) || (a.x-b.x))
      .map(c => `(${c.x+1},${c.y+1})`);
    return arr.join(" ");
  }

  function clearMarks(){
    for (let y=0; y<N; y++){
      for (let x=0; x<N; x++){
        cellEls[y][x].classList.remove("mark");
      }
    }
  }

  function markSquare(cells){
    cells.forEach(c => cellEls[c.y][c.x].classList.add("mark"));
  }

  // init
  renderAll();
  logLine("æ–°å±€é–‹å§‹ï¼šé»‘æ£‹å…ˆè¡Œã€‚");
})();
</script>
</body>
</html>

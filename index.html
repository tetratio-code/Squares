<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>9Ã—9 æ­£æ–¹å½¢æå­æ£‹</title>
  <style>
    :root{
      --bg:#101a33;
      --panel:#0f1a33;
      --line:#1f2a44;
      --text:#e8eefc;
      --muted:#a9b6d6;
      --black:#0b0b0b;
      --white:#f2f2f2;
      --accent:#6aa9ff;
      --danger:#ff6a7a;
      --cell-base: rgba(255,255,255,.10);
    }

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans TC", Arial;
      background:
        radial-gradient(1200px 800px at 20% 10%, #223a7a 0%, var(--bg) 55%),
        radial-gradient(900px 700px at 85% 15%, rgba(106,169,255,.18) 0%, rgba(0,0,0,0) 55%);
      color:var(--text);
    }

    .wrap{
      max-width:1100px; margin:24px auto; padding:0 16px;
      display:grid; gap:16px; grid-template-columns: 1fr 320px;
    }
    .card{
      background:rgba(15,26,51,.88);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      box-shadow: 0 12px 32px rgba(0,0,0,.35);
    }
    .boardCard{ padding:16px; }
    .side{ padding:16px; display:flex; flex-direction:column; gap:12px; }
    h1{ font-size:18px; margin:0 0 8px 0; letter-spacing:.5px; }
    .sub{ color:var(--muted); font-size:13px; line-height:1.5; }

    .topbar{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; flex-wrap:wrap; }
    .pill{
      display:inline-flex; align-items:center; gap:8px; padding:8px 10px;
      border-radius:999px; background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10); font-size:13px;
    }
    .dot{ width:10px; height:10px; border-radius:50%; }
    .dot.black{ background:var(--black); box-shadow:0 0 0 2px rgba(255,255,255,.15) inset; }
    .dot.white{ background:var(--white); box-shadow:0 0 0 2px rgba(0,0,0,.18) inset; }
    .dot.phase{ background:var(--accent); }
    .scoreRow{ display:flex; gap:8px; flex-wrap:wrap; }

    .board{
      width:min(78vmin, 620px);
      aspect-ratio:1/1;
      margin:0 auto;
      display:grid;
      grid-template-columns: repeat(9, 1fr);
      border-radius:14px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.12);

      /* å–æ¶ˆæ£‹ç›¤æœ¬èº«æ¼¸å±¤ */
      background: rgba(0,0,0,.10);
    }

    .cell{
      position:relative;
      border:1px solid rgba(255,255,255,.08);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer; user-select:none;

      /* æ¯æ ¼ç”¨ç´”è‰²ï¼Œä¸ç”¨æ¼¸å±¤ */
      background: var(--cell-base);
    }

    .cell.disabled{ cursor:not-allowed; opacity:.78; }
    .cell.disabled:hover{ background: var(--cell-base); }

    .stone{
      width:70%; height:70%;
      border-radius:50%;
      transform: translateZ(0);
      box-shadow: 0 10px 16px rgba(0,0,0,.35);
      position:relative;
      z-index: 1;
    }
    .stone.black{
      background: radial-gradient(circle at 30% 30%, #2a2a2a 0%, var(--black) 65%);
      outline: 1px solid rgba(255,255,255,.08);
    }
    .stone.white{
      background: radial-gradient(circle at 30% 30%, #ffffff 0%, var(--white) 65%);
      outline: 1px solid rgba(0,0,0,.10);
    }

    /* æ¨™ç¤ºè½å­è™•ï¼šå¯¦å¿ƒæ¨™è¨˜ */
    .cell.lastmove::after{
      content:"";
      position:absolute;
      width:10px; height:10px;
      border-radius:50%;
      background: rgba(255, 215, 102, .95);
      box-shadow: 0 0 0 2px rgba(0,0,0,.35);
      z-index: 3;
      top:50%; left:50%;
      transform: translate(-50%,-50%);
      pointer-events:none;
    }

    /* æ¨™ç¤ºææ­£æ–¹å½¢å››è§’ï¼šç©ºå¿ƒæ¨™è¨˜ï¼ˆæœƒä¿ç•™åˆ°ä¸‹ä¸€æ¬¡è½å­ï¼‰ */
    .cell.sqcorner::before{
      content:"";
      position:absolute;
      width:22px; height:22px;
      border-radius:50%;
      border: 2px solid rgba(106,169,255,.95);
      box-shadow: 0 0 0 2px rgba(0,0,0,.22) inset;
      z-index: 2;
      top:50%; left:50%;
      transform: translate(-50%,-50%);
      pointer-events:none;
    }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
      letter-spacing:.2px;
    }
    button:hover{ background: rgba(255,255,255,.10); }
    button:disabled{ opacity:.45; cursor:not-allowed; }
    .primary{ border-color: rgba(106,169,255,.45); background: rgba(106,169,255,.16); }
    .primary:hover{ background: rgba(106,169,255,.22); }
    .danger{ border-color: rgba(255,106,122,.45); background: rgba(255,106,122,.14); }
    .danger:hover{ background: rgba(255,106,122,.20); }

    .list{
      max-height:260px;
      overflow:auto;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
    }
    .item{
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.07);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-size:13px;
      cursor:pointer;
    }
    .item:last-child{ border-bottom:none; }
    .item:hover{ background: rgba(255,255,255,.06); }
    .item.sel{ background: rgba(106,169,255,.18); border-bottom-color: rgba(106,169,255,.25); }
    .badge{
      font-size:12px; color:var(--muted);
      padding:3px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      white-space:nowrap;
    }

    .log{
      font-size:13px; line-height:1.5;
      color: var(--muted);
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
      padding:10px;
      min-height:92px;
      white-space:pre-wrap;
    }

    .footerHint{ color:var(--muted); font-size:12px; line-height:1.5; }
    @media (max-width: 920px){
      .wrap{ grid-template-columns: 1fr; }
      .board{ width:min(92vmin, 620px); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card boardCard">
      <div class="topbar">
        <div>
          <h1>æ­£æ–¹å½¢æå­æ£‹ v1.3</h1>
          <div class="sub">é»‘æ£‹å…ˆè¡Œï¼ˆç©å®¶ï¼é»‘ï¼‰ï¼Œç™½æ£‹ç‚ºæ™ºæ…§ CPUã€‚æ¯å›åˆï¼šä¸‹æ£‹ â†’ï¼ˆè‹¥å¯æå­å‰‡å¿…é ˆæå­ï¼‰â†’ çµæŸå›åˆã€‚</div>
        </div>
        <div class="scoreRow">
          <div class="pill"><span class="dot black" id="turnDot"></span><span id="turnText">é»‘æ–¹å›åˆ</span></div>
          <div class="pill"><span class="dot phase"></span><span id="phaseText">ä¸‹æ£‹éšæ®µ</span></div>
          <div class="pill"><span>é»‘åˆ†ï¼š</span><b id="scoreB">0</b></div>
          <div class="pill"><span>ç™½åˆ†ï¼š</span><b id="scoreW">0</b></div>
          <div class="pill"><span>ç›®æ¨™ï¼š</span><b>81</b></div>
        </div>
      </div>

      <div class="board" id="board"></div>
    </div>

    <div class="card side">
      <div class="sub">
        <b>æå­è¦å‰‡ï¼š</b>æå­éšæ®µï¼Œè‹¥ã€Œç•¶å‰ç©å®¶çš„ä»»å››é¡†æ£‹ã€èƒ½å½¢æˆæ­£æ–¹å½¢ï¼ˆæ–œçš„ä¹Ÿç®—ï¼‰ï¼Œå³å¯å°‡ã€Œé€™å››é¡†è‡ªå·±çš„æ£‹ã€ææ‰ï¼Œä¸¦ç²å¾—è©²æ­£æ–¹å½¢é¢ç©åˆ†æ•¸ï¼ˆ= é‚Šé•·Â²ï¼‰ã€‚<br>
        <b>å¼·åˆ¶æå­ï¼š</b>è‹¥å­˜åœ¨å¯ç”¨æ­£æ–¹å½¢ï¼Œæœ¬å›åˆå¿…é ˆæå­ï¼ˆå¯é¸è¦æå“ªä¸€å€‹æ­£æ–¹å½¢ï¼‰ã€‚
      </div>

      <div>
        <div class="pill" style="width:100%; justify-content:space-between;">
          <span>å¯ç”¨æ­£æ–¹å½¢</span>
          <span class="badge" id="sqCount">0</span>
        </div>
        <div class="list" id="sqList"></div>
      </div>

      <div class="btnRow">
        <button class="primary" id="btnCaptureSquare">æå­ï¼ˆç§»é™¤4å­ï¼‰</button>
        <button class="primary" id="btnSkipCapture">è·³éæå­</button>
        <button class="primary" id="btnEndTurn">çµæŸå›åˆ â†’</button>
        <button class="danger" id="btnRestart">é‡æ–°é–‹å§‹</button>
      </div>

      <div class="log" id="log"></div>

      <div class="footerHint">
        æ¨™è¨˜èªªæ˜ï¼š<br>
        â— å¯¦å¿ƒé»ï¼ä¸Šä¸€æ­¥è½å­ä½ç½®<br>
        â—‹ ç©ºå¿ƒåœˆï¼ç›®å‰é¸ä¸­çš„æ­£æ–¹å½¢å››è§’ï¼ˆæå­å¾Œæœƒä¿ç•™ï¼Œç›´åˆ°ä¸‹ä¸€æ¬¡è½å­ï¼‰<br><br>
        æ“ä½œæç¤ºï¼š<br>
        1) ä¸‹æ£‹éšæ®µï¼šé»ç©ºæ ¼ä¸‹ 1 é¡†ï¼ˆå¯è½å­æ ¼æœƒæ›´äº®ï¼‰ã€‚<br>
        2) è‹¥å¯æå­ï¼šå…ˆåœ¨å³å´é¸æ­£æ–¹å½¢ï¼ŒæŒ‰ã€Œæå­ã€å¾—åˆ†ã€‚<br>
        3) è‹¥ç„¡å¯æå­ï¼šå¯ç›´æ¥çµæŸå›åˆã€‚
      </div>
    </div>
  </div>

<script>
(() => {
  const N = 9;
  const TARGET = 81;

  // ===== helpers =====
  function inBoard(x,y){ return x>=0 && x<N && y>=0 && y<N; }
  function keyXY(x,y){ return `${x},${y}`; }
  function other(t){ return t === 1 ? 2 : 1; }
  function turnName(t){ return t === 1 ? "é»‘æ–¹" : "ç™½æ–¹"; }

  // ===== state =====
  let board = Array.from({length:N}, () => Array(N).fill(0));
  let turn = 1;                 // 1 black, 2 white
  let phase = "place";          // "place" | "capture"
  let placedThisTurn = false;

  let scoreB = 0, scoreW = 0;

  let availableSquares = [];
  let selectedSquareKey = null;
  let captureDoneThisTurn = false;

  let lastMove = null;          // {x,y}

  // é‡è¦ï¼šæå­å¾Œç©ºå¿ƒæ¨™è¨˜è¦ä¿ç•™åˆ°ã€Œä¸‹ä¸€æ¬¡è½å­ã€
  let pendingClearSquareMarkers = false;

  // ===== DOM =====
  const elBoard = document.getElementById("board");
  const elPhaseText = document.getElementById("phaseText");
  const elTurnText = document.getElementById("turnText");
  const elTurnDot  = document.getElementById("turnDot");
  const elScoreB = document.getElementById("scoreB");
  const elScoreW = document.getElementById("scoreW");
  const elSqList = document.getElementById("sqList");
  const elSqCount = document.getElementById("sqCount");
  const elLog = document.getElementById("log");
  const btnSkipCapture = document.getElementById("btnSkipCapture");
  const btnEndTurn = document.getElementById("btnEndTurn");
  const btnRestart = document.getElementById("btnRestart");
  const btnCaptureSquare = document.getElementById("btnCaptureSquare");

  // ===== build grid =====
  const cellEls = Array.from({length:N}, () => Array(N).fill(null));
  for (let y=0; y<N; y++){
    for (let x=0; x<N; x++){
      const d = document.createElement("div");
      d.className = "cell";
      d.addEventListener("click", () => onCellClick(x,y));
      elBoard.appendChild(d);
      cellEls[y][x] = d;
    }
  }

  // ===== UI marker helpers =====
  function clearSquareMarkers(){
    for (let y=0; y<N; y++) for (let x=0; x<N; x++) cellEls[y][x].classList.remove("sqcorner");
  }
  function markSquareCorners(cells){
    cells.forEach(c => cellEls[c.y][c.x].classList.add("sqcorner"));
  }

  function logLine(s){
    const cur = elLog.textContent.split("\n");
    if (cur.length && cur[cur.length-1] === s) return;
    elLog.textContent += (elLog.textContent ? "\n" : "") + s;
    elLog.scrollTop = elLog.scrollHeight;
  }

  // ===== game flow =====
  btnSkipCapture.addEventListener("click", () => {
    if (phase !== "capture" || turn !== 1) return;
    if (availableSquares.length > 0) {
      logLine("æ­¤å›åˆå­˜åœ¨å¯ç”¨æ­£æ–¹å½¢ï¼Œå¿…é ˆæå­ï¼ˆå¯é¸è¦æå“ªå€‹ï¼‰ã€‚");
      return;
    }
    captureDoneThisTurn = true;
    selectedSquareKey = null;
    renderSquares([]);
    logLine(`${turnName(turn)} è·³éæå­ã€‚`);
    updateButtons();
  });

  btnCaptureSquare.addEventListener("click", () => {
    if (phase !== "capture" || turn !== 1) return;
    if (captureDoneThisTurn) return;

    if (availableSquares.length === 0) { logLine("ç›®å‰æ²’æœ‰å¯ç”¨æ­£æ–¹å½¢ï¼Œç„¡æ³•æå­ã€‚"); return; }
    if (!selectedSquareKey) { logLine("è«‹å…ˆåœ¨å³å´é¸ä¸€å€‹æ­£æ–¹å½¢ã€‚"); return; }

    const sq = availableSquares.find(s => s.key === selectedSquareKey);
    if (!sq) return;

    // ç§»é™¤è‡ªå·±å½¢æˆæ­£æ–¹å½¢çš„å››é¡†æ£‹
    sq.cells.forEach(c => { if (board[c.y][c.x] === 1) board[c.y][c.x] = 0; });

    addScore(1, sq.area);
    captureDoneThisTurn = true;

    // æå­å¾Œï¼šç©ºå¿ƒæ¨™è¨˜ä¿ç•™åˆ°ã€Œä¸‹ä¸€æ¬¡è½å­ã€
    pendingClearSquareMarkers = true;

    logLine(`${turnName(1)} æå­ï¼šç§»é™¤è‡ªå·± 4 å­ï¼ˆé¢ç© ${sq.area}ï¼‰ï¼Œå¾—åˆ† +${sq.area}ã€‚`);
    selectedSquareKey = null;
    renderAll();
    checkWinMaybe();
  });

  btnEndTurn.addEventListener("click", () => {
    if (!canEndTurn()) return;
    endTurn();
  });

  btnRestart.addEventListener("click", () => resetGame());

  function resetGame(){
    board = Array.from({length:N}, () => Array(N).fill(0));
    turn = 1;
    phase = "place";
    placedThisTurn = false;
    scoreB = 0; scoreW = 0;
    availableSquares = [];
    selectedSquareKey = null;
    captureDoneThisTurn = false;
    lastMove = null;
    pendingClearSquareMarkers = false;
    elLog.textContent = "";
    clearSquareMarkers();
    renderAll();
    logLine("æ–°å±€é–‹å§‹ï¼šé»‘æ£‹å…ˆè¡Œã€‚");
  }

  function renderAll(){
    // stones + base classes
    for (let y=0; y<N; y++){
      for (let x=0; x<N; x++){
        const c = cellEls[y][x];
        c.innerHTML = "";
        c.classList.remove("disabled","lastmove","playable");
        const v = board[y][x];
        if (v === 1){
          const s = document.createElement("div");
          s.className = "stone black";
          c.appendChild(s);
        } else if (v === 2){
          const s = document.createElement("div");
          s.className = "stone white";
          c.appendChild(s);
        }
      }
    }

    // last move marker
    if (lastMove && inBoard(lastMove.x, lastMove.y)) cellEls[lastMove.y][lastMove.x].classList.add("lastmove");

    // top pills
    elPhaseText.textContent = (phase === "place") ? "ä¸‹æ£‹éšæ®µ" : "æå­éšæ®µ";
    elTurnText.textContent = `${turnName(turn)}å›åˆ`;
    elTurnDot.className = "dot " + (turn === 1 ? "black" : "white");
    elScoreB.textContent = scoreB;
    elScoreW.textContent = scoreW;

    // playable highlighting + disable
    for (let y=0; y<N; y++){
      for (let x=0; x<N; x++){
        const c = cellEls[y][x];
        c.classList.remove("disabled");
    
        if (phase === "place"){
          // ä¸‹æ£‹éšæ®µ
          if (board[y][x] !== 0 || placedThisTurn || turn !== 1){
            c.classList.add("disabled");
          }
        } else {
          // capture éšæ®µå…¨éƒ¨ç¦ç”¨ï¼ˆç”±å³å´æŒ‰éˆ•æ“ä½œï¼‰
          c.classList.add("disabled");
        }
      }
    }

    // squares list refresh when entering capture on human turn
    if (phase === "capture" && turn === 1){
      availableSquares = findSquares(1);
      renderSquares(availableSquares);
      elSqCount.textContent = availableSquares.length;
      if (availableSquares.length > 0 && !captureDoneThisTurn) logLine("æ­¤å›åˆå­˜åœ¨å¯ç”¨æ­£æ–¹å½¢ï¼šå¿…é ˆæå­ï¼ˆå¯é¸è¦æå“ªå€‹ï¼‰ã€‚");
    } else {
      renderSquares([]);
      elSqCount.textContent = 0;
    }

    updateButtons();
  }

  function updateButtons(){
    const isHumanCapture = (phase === "capture" && turn === 1 && !captureDoneThisTurn);
    const mustCapture = isHumanCapture && (availableSquares.length > 0);

    btnCaptureSquare.disabled = !(isHumanCapture && mustCapture && !!selectedSquareKey);
    btnSkipCapture.disabled = !(isHumanCapture && !mustCapture);
    btnEndTurn.disabled = !canEndTurn();
  }

  function canEndTurn(){
    if (turn === 2) return false;
    if (phase === "place") return false;
    if (availableSquares.length > 0) return captureDoneThisTurn; // å¼·åˆ¶æå­
    return true;
  }

  function onCellClick(x,y){
    if (turn !== 1) return;
    if (phase !== "place") return;
    if (placedThisTurn) return;
    if (board[y][x] !== 0) return;

    // è½å­å‰ï¼šè‹¥ä¸Šä¸€æ‰‹æœ‰ã€Œæå­å¾Œä¿ç•™çš„ç©ºå¿ƒæ¨™è¨˜ã€ï¼Œæ­¤åˆ»æ¸…æ‰
    if (pendingClearSquareMarkers) {
      clearSquareMarkers();
      pendingClearSquareMarkers = false;
    } else {
      // ä¹Ÿæ¸…æ‰ã€Œé¸æ­£æ–¹å½¢ä½†å°šæœªæå­ã€çš„æ¨™è¨˜ï¼ˆé¿å…è·¨æ‰‹æ®˜ç•™ï¼‰
      clearSquareMarkers();
    }

    board[y][x] = 1;
    lastMove = {x,y};
    placedThisTurn = true;

    logLine(`${turnName(1)} ä¸‹åœ¨ (${x+1},${y+1})ã€‚`);

    phase = "capture";
    captureDoneThisTurn = false;
    selectedSquareKey = null;
    renderAll();

    if (availableSquares.length === 0) logLine(`${turnName(1)} æ²’æœ‰å¯ç”¨æ­£æ–¹å½¢ï¼Œæœ¬å›åˆç„¡æ³•æå­ã€‚å¯ç›´æ¥çµæŸå›åˆã€‚`);
    else logLine(`è«‹å…ˆåœ¨å³å´é¸ä¸€å€‹æ­£æ–¹å½¢ï¼ŒæŒ‰ã€Œæå­ï¼ˆç§»é™¤4å­ï¼‰ã€å¾—åˆ†ï¼ˆæ­¤å›åˆå¼·åˆ¶æå­ï¼‰ã€‚`);
  }

  function endTurn(){
    phase = "place";
    placedThisTurn = false;
    captureDoneThisTurn = false;
    selectedSquareKey = null;

    // çµæŸå›åˆä¸æ¸… sqcornerï¼šè‹¥å‰›æå­ï¼Œæ¨™è¨˜ä¿ç•™åˆ°ä¸‹ä¸€æ¬¡è½å­ï¼ˆCPU è½å­ä¹Ÿç®—ï¼‰
    turn = 2;
    renderAll();
    checkWinMaybe();
    maybeCpuAuto();
  }

  function maybeCpuAuto(){
    if (turn !== 2) return;
    setTimeout(() => {
      cpuPlace();        // CPU è½å­æ™‚æœƒè™•ç† pendingClearSquareMarkers
      phase = "capture";
      captureDoneThisTurn = false;
      selectedSquareKey = null;

      availableSquares = findSquares(2);
      if (availableSquares.length === 0){
        logLine(`ç™½æ–¹ï¼ˆCPUï¼‰æ²’æœ‰å¯ç”¨æ­£æ–¹å½¢ï¼Œç„¡æ³•æå­ã€‚`);
        captureDoneThisTurn = true;
        checkWinMaybe();
        setTimeout(endTurnCPU, 250);
        return;
      }

      const sq = availableSquares[0]; // æœ€å¤§é¢ç©
      // æå­ï¼šç§»é™¤è‡ªå·±å››é¡†
      sq.cells.forEach(c => { if (board[c.y][c.x] === 2) board[c.y][c.x] = 0; });
      addScore(2, sq.area);

      // CPU æå­å¾Œä¹Ÿä¿ç•™æ¨™è¨˜åˆ°ä¸‹ä¸€æ¬¡è½å­
      clearSquareMarkers();
      markSquareCorners(sq.cells);
      pendingClearSquareMarkers = true;

      logLine(`ç™½æ–¹ï¼ˆCPUï¼‰æå­ï¼šç§»é™¤è‡ªå·± 4 å­ï¼ˆé¢ç© ${sq.area}ï¼‰ï¼Œå¾—åˆ† +${sq.area}ã€‚`);
      captureDoneThisTurn = true;

      renderAll();
      checkWinMaybe();
      setTimeout(endTurnCPU, 300);
    }, 300);
  }

  function endTurnCPU(){
    phase = "place";
    placedThisTurn = false;
    captureDoneThisTurn = false;
    selectedSquareKey = null;
    turn = 1;
    renderAll();
  }

  // ===== Smarter CPU placement =====
  function cpuPlace(){
    // CPU è½å­å‰ï¼šè‹¥ä¸Šä¸€æ‰‹æå­ç•™ä¸‹æ¨™è¨˜ï¼Œç¾åœ¨æ¸…æ‰ï¼ˆç¬¦åˆã€Œä¿ç•™ç›´åˆ°å°æ–¹/å·±æ–¹è½å­ã€ï¼‰
    if (pendingClearSquareMarkers) {
      clearSquareMarkers();
      pendingClearSquareMarkers = false;
    } else {
      clearSquareMarkers();
    }

    const my = imminentMoves(2);
    let pick = pickBestFromMoveMap(my);
    if (!pick) pick = pickBestFromMoveMap(imminentMoves(1));
    if (!pick) {
      const empties = [];
      for (let yy=0; yy<N; yy++) for (let xx=0; xx<N; xx++) if (board[yy][xx] === 0) empties.push({x:xx,y:yy});
      if (empties.length === 0){ logLine("æ£‹ç›¤å·²æ»¿ã€‚"); return; }
      pick = empties[Math.floor(Math.random()*empties.length)];
    }

    board[pick.y][pick.x] = 2;
    lastMove = {x: pick.x, y: pick.y};

    const k = keyXY(pick.x, pick.y);
    let note = "";
    if (my.has(k)) note = `ï¼ˆå®Œæˆæ­£æ–¹å½¢æ©Ÿæœƒï¼šæœ€é«˜é¢ç© ${my.get(k).bestArea}ï¼‰`;
    else {
      const oppNow = imminentMoves(1);
      if (oppNow.has(k)) note = `ï¼ˆé˜»æ“‹é»‘æ–¹æ©Ÿæœƒï¼šæœ€é«˜é¢ç© ${oppNow.get(k).bestArea}ï¼‰`;
    }
    logLine(`ç™½æ–¹ï¼ˆCPUï¼‰ä¸‹åœ¨ (${pick.x+1},${pick.y+1})ã€‚${note}`);
    renderAll();
  }

  function addScore(color, delta){
    if (color === 1) scoreB += delta;
    else scoreW += delta;
    elScoreB.textContent = scoreB;
    elScoreW.textContent = scoreW;
  }

  function checkWinMaybe(){
    if (scoreB >= TARGET || scoreW >= TARGET){
      const winner = scoreB >= TARGET ? "é»‘æ–¹ï¼ˆç©å®¶ï¼‰" : "ç™½æ–¹ï¼ˆCPUï¼‰";
      logLine(`\nğŸ ${winner} å…ˆé”åˆ° ${TARGET} åˆ†ï¼Œç²å‹ï¼`);
      for (let y=0; y<N; y++) for (let x=0; x<N; x++) cellEls[y][x].classList.add("disabled");
      btnCaptureSquare.disabled = true;
      btnSkipCapture.disabled = true;
      btnEndTurn.disabled = true;
    }
  }

  // ===== Precompute all possible squares =====
  const ALL_SQUARES = (() => {
    const m = new Map();
    for (let y = 0; y < N; y++) for (let x = 0; x < N; x++) {
      for (let dx = -8; dx <= 8; dx++) for (let dy = -8; dy <= 8; dy++) {
        if (dx === 0 && dy === 0) continue;
        const p = { x, y };
        const q = { x: x + dx, y: y + dy };
        if (!inBoard(q.x, q.y)) continue;
        for (const [rx, ry] of [[-dy, dx], [dy, -dx]]) {
          const r = { x: x + rx, y: y + ry };
          const s = { x: q.x + rx, y: q.y + ry };
          if (!inBoard(r.x, r.y) || !inBoard(s.x, s.y)) continue;
          const cells = [p, q, r, s].map(z => ({ x: z.x, y: z.y }));
          const canon = cells.map(c => keyXY(c.x, c.y)).sort().join("|");
          if (!m.has(canon)) m.set(canon, { cells, area: dx*dx + dy*dy, key: canon });
        }
      }
    }
    return Array.from(m.values()).sort((a, b) => b.area - a.area);
  })();

  function imminentMoves(color) {
    const res = new Map();
    for (const sq of ALL_SQUARES) {
      let mine = 0, empty = 0, emptyCell = null, blocked = false;
      for (const c of sq.cells) {
        const v = board[c.y][c.x];
        if (v === color) mine++;
        else if (v === 0) { empty++; emptyCell = c; }
        else { blocked = true; break; }
      }
      if (blocked) continue;
      if (mine === 3 && empty === 1 && emptyCell) {
        const k = keyXY(emptyCell.x, emptyCell.y);
        const cur = res.get(k) || { bestArea: 0, sumArea: 0, x: emptyCell.x, y: emptyCell.y };
        cur.bestArea = Math.max(cur.bestArea, sq.area);
        cur.sumArea += sq.area;
        res.set(k, cur);
      }
    }
    return res;
  }

  function pickBestFromMoveMap(moveMap) {
    let best = null;
    for (const v of moveMap.values()) {
      if (!best) best = v;
      else if (v.bestArea > best.bestArea) best = v;
      else if (v.bestArea === best.bestArea && v.sumArea > best.sumArea) best = v;
    }
    return best;
  }

  // ===== Find actual squares for capture list =====
  function findSquares(color){
    const pts = [];
    for (let y=0; y<N; y++) for (let x=0; x<N; x++) if (board[y][x] === color) pts.push({x,y});
    const has = new Set(pts.map(p => keyXY(p.x,p.y)));

    const sqMap = new Map();
    for (let i=0; i<pts.length; i++){
      for (let j=0; j<pts.length; j++){
        if (i === j) continue;
        const p = pts[i], q = pts[j];
        const dx = q.x - p.x, dy = q.y - p.y;
        if (dx === 0 && dy === 0) continue;

        for (const [rx, ry] of [[-dy, dx],[dy, -dx]]){
          const r = {x: p.x + rx, y: p.y + ry};
          const s = {x: q.x + rx, y: q.y + ry};
          if (!inBoard(r.x,r.y) || !inBoard(s.x,s.y)) continue;
          if (!has.has(keyXY(r.x,r.y)) || !has.has(keyXY(s.x,s.y))) continue;

          const cells = [p,q,r,s].map(z => ({x:z.x,y:z.y}));
          const canon = cells.map(z => keyXY(z.x,z.y)).sort().join("|");
          const area = dx*dx + dy*dy;
          if (!sqMap.has(canon)) sqMap.set(canon, { cells, area, key: canon });
        }
      }
    }
    return Array.from(sqMap.values()).sort((a,b) => b.area - a.area);
  }

  // ===== square list =====
  function renderSquares(squares){
    elSqList.innerHTML = "";
    if (!squares || squares.length === 0){
      const empty = document.createElement("div");
      empty.className = "item";
      empty.style.cursor = "default";
      empty.style.color = "var(--muted)";
      empty.textContent = (phase === "capture" && turn === 1) ? "ï¼ˆæ²’æœ‰å¯ç”¨æ­£æ–¹å½¢ï¼‰" : "ï¼ˆå›åˆä¸­æ‰æœƒé¡¯ç¤ºï¼‰";
      elSqList.appendChild(empty);
      return;
    }

    squares.forEach((sq, idx) => {
      const it = document.createElement("div");
      it.className = "item" + (sq.key === selectedSquareKey ? " sel" : "");

      const left = document.createElement("div");
      left.textContent = `#${idx+1} é¢ç© ${sq.area}`;

      const right = document.createElement("span");
      right.className = "badge";
      right.textContent = sq.cells.slice().sort((a,b)=> (a.y-b.y)||(a.x-b.x)).map(c=>`(${c.x+1},${c.y+1})`).join(" ");

      it.appendChild(left);
      it.appendChild(right);

      it.addEventListener("click", () => {
        if (phase !== "capture" || turn !== 1) return;
        if (captureDoneThisTurn) return;
        if (availableSquares.length === 0) return;

        selectedSquareKey = sq.key;

        // é¸æ“‡æ­£æ–¹å½¢ï¼šé¡¯ç¤ºç©ºå¿ƒåœˆï¼ˆä¸è¨­å®š pendingClearï¼Œå› ç‚ºé‚„æ²’æå­ï¼‰
        clearSquareMarkers();
        markSquareCorners(sq.cells);

        renderSquares(availableSquares);
        logLine(`å·²é¸æ­£æ–¹å½¢ï¼ˆé¢ç© ${sq.area}ï¼‰ï¼šæŒ‰ã€Œæå­ï¼ˆç§»é™¤4å­ï¼‰ã€å³å¯å¾—åˆ†ã€‚`);
        updateButtons();
      });

      elSqList.appendChild(it);
    });
  }

  // init
  resetGame();
})();
</script>
</body>
</html>

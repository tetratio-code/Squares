<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>正方形提子棋 Bitboard 版</title>
  <style>
    :root {
      --bg: #0a0f1e;
      --panel: #111a33;
      --accent: #4a90e2;
      --danger: #e74c3c;
      --text: #e0e6ed;
      --muted: #8892b0;
    }
    body {
      margin: 0; font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg); color: var(--text);
      display: flex; justify-content: center; padding: 20px;
    }
    .container {
      display: grid; grid-template-columns: 1fr 300px; gap: 20px;
      max-width: 1000px; width: 100%;
    }
    .card {
      background: var(--panel); border-radius: 12px; padding: 20px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .board {
      display: grid; grid-template-columns: repeat(9, 1fr);
      gap: 2px; background: #1f2a44; border: 4px solid #1f2a44;
      aspect-ratio: 1/1; width: 100%; max-width: 550px; margin: 0 auto;
    }
    .cell {
      background: var(--panel); display: flex; align-items: center;
      justify-content: center; cursor: pointer; position: relative;
    }
    .cell:hover { background: #1a264d; }
    .stone {
      width: 75%; height: 75%; border-radius: 50%;
      transition: transform 0.2s; z-index: 2;
    }
    .stone.black { background: #111; box-shadow: 0 4px 8px rgba(0,0,0,0.5); }
    .stone.white { background: #fff; box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
    
    .last-move::after {
      content: ""; position: absolute; width: 8px; height: 8px;
      background: #f1c40f; border-radius: 50%; z-index: 3;
    }
    .highlight-sq::before {
      content: ""; position: absolute; width: 90%; height: 90%;
      border: 2px solid var(--accent); border-radius: 50%; z-index: 1;
    }

    .info-panel { display: flex; flex-direction: column; gap: 15px; }
    .stat-box {
      display: flex; justify-content: space-between; padding: 10px;
      background: rgba(255,255,255,0.05); border-radius: 8px;
    }
    .log {
      height: 150px; overflow-y: auto; background: #000;
      padding: 10px; font-size: 12px; color: #0f0; font-family: monospace;
      border-radius: 5px;
    }
    button {
      padding: 12px; border: none; border-radius: 6px; cursor: pointer;
      font-weight: bold; transition: 0.2s;
    }
    .btn-primary { background: var(--accent); color: white; }
    .btn-primary:disabled { background: #444; cursor: not-allowed; }
    
    @media (max-width: 800px) {
      .container { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

<div class="container">
  <div class="card">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
      <h2 style="margin:0">正方形提子棋 <small style="font-size:12px; color:var(--muted)">Bitboard Engine</small></h2>
      <div id="status">黑方回合</div>
    </div>
    <div class="board" id="board"></div>
  </div>

  <div class="info-panel">
    <div class="card">
      <div class="stat-box"><span>黑方分數:</span><span id="score1">0</span></div>
      <div class="stat-box"><span>白方分數:</span><span id="score2">0</span></div>
      <div style="font-size:12px; margin-top:10px; color:var(--muted)">目標: 81 分</div>
    </div>

    <div class="card">
      <div style="margin-bottom:8px">可用提子:</div>
      <select id="sqSelect" size="5" style="width:100%; background:#1a264d; color:white; border:1px solid #333; border-radius:4px; padding:5px;"></select>
      <button id="btnCapture" class="btn-primary" style="width:100%; margin-top:10px;" disabled>執行提子</button>
    </div>

    <div class="log" id="log"></div>
    <button onclick="resetGame()" style="background:#333; color:white">重新開始</button>
  </div>
</div>

<script>
/**
 * BITBOARD ENGINE CONFIG
 */
const N = 9;
const SIZE = N * N;
const TARGET = 81;
const AI_COLOR = 2; // 1:Black, 2:White
const HUMAN_COLOR = 1;

// Bitboard logic using BigInt
const bit = (i) => 1n << BigInt(i);

// Precompute all possible squares
const ALL_SQUARES = (() => {
  const squares = [];
  for (let y1 = 0; y1 < N; y1++) {
    for (let x1 = 0; x1 < N; x1++) {
      for (let y2 = 0; y2 < N; y2++) {
        for (let x2 = 0; x2 < N; x2++) {
          if (x1 === x2 && y1 === y2) continue;
          
          let dx = x2 - x1;
          let dy = y2 - y1;
          
          // Based on P1, P2, find P3, P4 to form a square
          // (x3, y3) = (x2 - dy, y2 + dx)
          // (x4, y4) = (x1 - dy, y1 + dx)
          let x3 = x2 - dy, y3 = y2 + dx;
          let x4 = x1 - dy, y4 = y1 + dx;

          if (x3 >= 0 && x3 < N && y3 >= 0 && y3 < N && x4 >= 0 && x4 < N && y4 >= 0 && y4 < N) {
            let mask = bit(y1*N+x1) | bit(y2*N+x2) | bit(y3*N+x3) | bit(y4*N+x4);
            let area = dx*dx + dy*dy;
            
            // Avoid duplicates by storing unique mask
            if (!squares.find(s => s.mask === mask)) {
              squares.push({ mask, area, indices: [y1*N+x1, y2*N+x2, y3*N+x3, y4*N+x4] });
            }
          }
        }
      }
    }
  }
  return squares.sort((a, b) => b.area - a.area);
})();

/**
 * GAME STATE
 */
let b1 = 0n; // Black stones
let b2 = 0n; // White stones
let score = [0, 0, 0];
let turn = 1;
let phase = 'place'; // 'place' | 'capture'
let lastMoveIdx = -1;
let availableSq = [];

/**
 * CORE LOGIC
 */
function getAvailableSquares(board) {
  return ALL_SQUARES.filter(sq => (board & sq.mask) === sq.mask);
}

function evaluate(black, white, s1, s2) {
  let scoreDiff = (s1 - s2) * 10;
  if (AI_COLOR === 2) scoreDiff = -scoreDiff;

  // Popcount (number of stones) - Simplified for BigInt
  const countSetBits = (n) => {
    let count = 0;
    while (n > 0n) { n &= (n - 1n); count++; }
    return count;
  };

  // Threat detection (3 out of 4 bits)
  const getThreats = (board, oppBoard) => {
    let t = 0;
    for (const sq of ALL_SQUARES) {
      if ((oppBoard & sq.mask) === 0n) { // No opponent stones blocking
        let mine = countSetBits(board & sq.mask);
        if (mine === 3) t += sq.area;
      }
    }
    return t;
  };

  let threats = getThreats(white, black) - getThreats(black, white);
  if (AI_COLOR === 1) threats = -threats;

  return scoreDiff + threats;
}

// Alpha-Beta Search
function minimax(black, white, s1, s2, depth, alpha, beta, isMax, color) {
  if (s1 >= TARGET) return isMax ? -99999 : 99999;
  if (s2 >= TARGET) return isMax ? 99999 : -99999;
  if (depth === 0) return evaluate(black, white, s1, s2);

  const occupied = black | white;
  if (occupied === (1n << 81n) - 1n) return evaluate(black, white, s1, s2);

  let moves = [];
  for (let i = 0; i < SIZE; i++) {
    if (!((occupied >> BigInt(i)) & 1n)) moves.push(i);
  }
  
  // Heuristic: move ordering (center first)
  moves.sort((a, b) => {
    const dist = (idx) => Math.abs(Math.floor(idx/N)-4) + Math.abs((idx%N)-4);
    return dist(a) - dist(b);
  });

  if (isMax) {
    let maxEval = -Infinity;
    for (let m of moves.slice(0, 15)) { // Branching factor reduction
      let nb = color === 1 ? black | bit(m) : black;
      let nw = color === 2 ? white | bit(m) : white;
      let ns1 = s1, ns2 = s2;

      let sqs = getAvailableSquares(color === 1 ? nb : nw);
      if (sqs.length > 0) {
        let bestSq = sqs[0]; // Greedy capture
        if (color === 1) { nb &= ~bestSq.mask; ns1 += bestSq.area; }
        else { nw &= ~bestSq.mask; ns2 += bestSq.area; }
      }
      
      let ev = minimax(nb, nw, ns1, ns2, depth - 1, alpha, beta, false, 3 - color);
      maxEval = Math.max(maxEval, ev);
      alpha = Math.max(alpha, ev);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (let m of moves.slice(0, 15)) {
      let nb = color === 1 ? black | bit(m) : black;
      let nw = color === 2 ? white | bit(m) : white;
      let ns1 = s1, ns2 = s2;

      let sqs = getAvailableSquares(color === 1 ? nb : nw);
      if (sqs.length > 0) {
        let bestSq = sqs[0];
        if (color === 1) { nb &= ~bestSq.mask; ns1 += bestSq.area; }
        else { nw &= ~bestSq.mask; ns2 += bestSq.area; }
      }

      let ev = minimax(nb, nw, ns1, ns2, depth - 1, alpha, beta, true, 3 - color);
      minEval = Math.min(minEval, ev);
      beta = Math.min(beta, ev);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

/**
 * UI & INTERACTION
 */
const elBoard = document.getElementById('board');
const elLog = document.getElementById('log');
const elSqSelect = document.getElementById('sqSelect');
const btnCapture = document.getElementById('btnCapture');

function initBoard() {
  elBoard.innerHTML = '';
  for (let i = 0; i < SIZE; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.onclick = () => handleCellClick(i);
    elBoard.appendChild(cell);
  }
}

function render() {
  const cells = elBoard.children;
  for (let i = 0; i < SIZE; i++) {
    cells[i].innerHTML = '';
    cells[i].className = 'cell';
    if ((b1 >> BigInt(i)) & 1n) {
      const s = document.createElement('div');
      s.className = 'stone black';
      cells[i].appendChild(s);
    } else if ((b2 >> BigInt(i)) & 1n) {
      const s = document.createElement('div');
      s.className = 'stone white';
      cells[i].appendChild(s);
    }
    if (i === lastMoveIdx) cells[i].classList.add('last-move');
  }

  document.getElementById('score1').innerText = score[1];
  document.getElementById('score2').innerText = score[2];
  document.getElementById('status').innerText = (turn === 1 ? "黑方" : "白方") + (phase === 'place' ? "下棋中" : "待提子");

  // Highlight selected square
  const selectedIdx = elSqSelect.selectedIndex;
  if (selectedIdx >= 0 && availableSq[selectedIdx]) {
    availableSq[selectedIdx].indices.forEach(idx => {
      cells[idx].classList.add('highlight-sq');
    });
  }
}

function log(msg) {
  elLog.innerHTML += `> ${msg}<br>`;
  elLog.scrollTop = elLog.scrollHeight;
}

async function handleCellClick(i) {
  if (turn !== HUMAN_COLOR || phase !== 'place') return;
  if (((b1 | b2) >> BigInt(i)) & 1n) return;

  makeMove(i);
  
  if (phase === 'capture' && availableSq.length === 0) {
    endTurn();
  }
}

function makeMove(i) {
  if (turn === 1) b1 |= bit(i); else b2 |= bit(i);
  lastMoveIdx = i;
  log(`${turn === 1 ? '黑' : '白'}落子: (${(i%N)+1}, ${Math.floor(i/N)+1})`);
  
  availableSq = getAvailableSquares(turn === 1 ? b1 : b2);
  if (availableSq.length > 0) {
    phase = 'capture';
    updateSqList();
  } else {
    phase = 'place';
  }
  render();
  checkWin();
}

function updateSqList() {
  elSqSelect.innerHTML = '';
  availableSq.forEach((sq, idx) => {
    const opt = document.createElement('option');
    opt.value = idx;
    opt.text = `正方形 #${idx+1} (面積: ${sq.area})`;
    elSqSelect.appendChild(opt);
  });
  btnCapture.disabled = availableSq.length === 0;
}

btnCapture.onclick = () => {
  const idx = elSqSelect.selectedIndex;
  if (idx < 0) return;
  
  const sq = availableSq[idx];
  if (turn === 1) b1 &= ~sq.mask; else b2 &= ~sq.mask;
  score[turn] += sq.area;
  log(`${turn === 1 ? '黑' : '白'}提子! 分數 +${sq.area}`);
  
  phase = 'place';
  endTurn();
};

elSqSelect.onchange = render;

function endTurn() {
  turn = 3 - turn;
  phase = 'place';
  availableSq = [];
  updateSqList();
  render();
  
  if (turn === AI_COLOR) {
    setTimeout(doAiMove, 500);
  }
}

function doAiMove() {
  log("AI 思考中...");
  let bestVal = -Infinity;
  let bestMove = -1;
  
  const occupied = b1 | b2;
  let moves = [];
  for (let i = 0; i < SIZE; i++) {
    if (!((occupied >> BigInt(i)) & 1n)) moves.push(i);
  }

  // Find best move using minimax
  for (let m of moves.slice(0, 20)) {
    let nb = AI_COLOR === 1 ? b1 | bit(m) : b1;
    let nw = AI_COLOR === 2 ? b2 | bit(m) : b2;
    let ns1 = score[1], ns2 = score[2];

    let sqs = getAvailableSquares(AI_COLOR === 1 ? nb : nw);
    if (sqs.length > 0) {
      if (AI_COLOR === 1) { nb &= ~sqs[0].mask; ns1 += sqs[0].area; }
      else { nw &= ~sqs[0].mask; ns2 += sqs[0].area; }
    }

    let val = minimax(nb, nw, ns1, ns2, 3, -Infinity, Infinity, false, 3 - AI_COLOR);
    if (val > bestVal) {
      bestVal = val;
      bestMove = m;
    }
  }

  if (bestMove !== -1) {
    makeMove(bestMove);
    if (phase === 'capture') {
      // AI always picks the largest square
      const sq = availableSq[0];
      if (turn === 1) b1 &= ~sq.mask; else b2 &= ~sq.mask;
      score[turn] += sq.area;
      log(`AI 提子: +${sq.area}`);
      phase = 'place';
      endTurn();
    } else {
      endTurn();
    }
  }
}

function checkWin() {
  if (score[1] >= TARGET || score[2] >= TARGET) {
    const winner = score[1] >= TARGET ? "黑方" : "白方";
    alert(`遊戲結束! ${winner} 獲勝!`);
    resetGame();
  }
}

function resetGame() {
  b1 = 0n; b2 = 0n;
  score = [0, 0, 0];
  turn = 1;
  phase = 'place';
  lastMoveIdx = -1;
  elLog.innerHTML = '';
  log("遊戲重置");
  render();
  updateSqList();
}

initBoard();
resetGame();
</script>

</body>
</html>
